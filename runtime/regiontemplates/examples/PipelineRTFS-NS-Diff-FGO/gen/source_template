/*
 * $NAME$.cpp
 *
 *  GENERATED CODE
 *  DO NOT CHANGE IT MANUALLY!!!!!
 */

#include "$NAME$.hpp"

#include <string>
#include <sstream>
#include <typeinfo>
#include <typeindex>

/**************************************************************************************/
/**************************** PipelineComponent functions *****************************/
/**************************************************************************************/

$NAME$::$NAME$() {
	this->setComponentName("$NAME$");

	// generate task descriptors
$STAGE_DESC_DECL$
$STAGE_DESC_DEF$
}

$NAME$::~$NAME$() {}

int $NAME$::run() {

	long long t0 = Util::ClockGetTime();

	// Print name and id of the component instance
	std::cout << "[Segmentation] Executing component: " << this->getComponentName() << " instance id: " << this->getId() <<std::endl;
	RegionTemplate * inputRt = this->getRegionTemplateInstance("tile");

$STAGE_INPUT_DR$
$STAGE_OUTPUT_DR$
	long long t1 = Util::ClockGetTime();

	map<int, ReusableTask*> prev_map;
	list<ReusableTask*> ordered_tasks;
	for (list<ReusableTask*>::reverse_iterator task=tasks.rbegin(); task!=tasks.rend(); task++) {
		// cout << "[Segmentation] sending task " << (*task)->getId() << endl;
		// generate a task copy and update the DR, getting the actual data
		ReusableTask* t = (*task)->clone();
		t->updateDR(inputRt);

		// solve dependency if it isn't the first task
		if (t->parentTask != -1) {
			// cout << "\t\t\t[Segmentation] setting dep of " << t->getId() << " to " << prev_map[t->parentTask]->getId() << endl;
			t->addDependency(prev_map[t->parentTask]->getId());

			if (t->parentTask != t->fakeParent)
				t->addDependency(t->fakeParent);

			t->resolveDependencies(prev_map[t->parentTask]);
		}

		// add this task to parent list for future dependency resolution
		prev_map[t->getId()] = t;
		ordered_tasks.emplace_back(t);
	}

	long long t2 = Util::ClockGetTime();

	// send all tasks to be executed
	for (ReusableTask* t : ordered_tasks) {
		cout << "\t\t\t[Segmentation] sending task " << t->getId() 
			<< " with dependencies:" << endl;
		for (int i=0; i<t->getNumberDependencies(); i++)
			cout << "\t\t\t\t" << t->getDependency(i) << ":" << endl;
		t->mock = false;
		this->executeTask(t);
	}

	long long t3 = Util::ClockGetTime();

	cout << "[SEGMENTATION_PROFILER] " << t0 << " " << t1 << " " << t2 << " " << t3 << endl;

	return 0;
}

// Create the component factory
PipelineComponentBase* componentFactory$NAME$() {
	return new $NAME$();
}

// register factory with the runtime system
bool registered$NAME$ = PipelineComponentBase::ComponentFactory::componentRegister("$NAME$", &componentFactory$NAME$);


/**************************************************************************************/
/*********************************** Task functions ***********************************/
/**************************************************************************************/

$TASKS$
